import { Bot } from 'grammy'
import { webhookCallback } from 'grammy'
import { NextRequest } from 'next/server'
import { prisma } from '@/lib/prisma'

const BOT_TOKEN = '7700098378:AAGZ1zZOxiwXbJeknO9SvyN25KvfWQkQNrI'
const ADMIN_IDS = ['316593422', '1837334996']

// –ü—Ä–æ—Å—Ç–æ–π –∞–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –∫–æ–º–∞–Ω–¥ –±–µ–∑ AI
function parseCommand(text: string) {
  const lower = text.toLowerCase()
  
  // –ó–∞–∫–∞–∑—ã
  if (lower.includes('–∑–∞–∫–∞–∑') || lower.includes('order')) {
    if (lower.includes('—Å–µ–≥–æ–¥–Ω—è') || lower.includes('today')) {
      return { action: 'view_orders', filter: 'today' }
    }
    if (lower.includes('–≤—á–µ—Ä–∞') || lower.includes('yesterday')) {
      return { action: 'view_orders', filter: 'yesterday' }
    }
    return { action: 'view_orders', filter: 'all' }
  }
  
  // –¢–æ–≤–∞—Ä—ã
  if (lower.includes('–¥–æ–±–∞–≤') && lower.includes('—Ç–æ–≤–∞—Ä')) {
    // –ò–∑–≤–ª–µ–∫–∞–µ–º –Ω–∞–∑–≤–∞–Ω–∏–µ –∏ —Ü–µ–Ω—É
    const priceMatch = text.match(/(\d+)/g)
    const price = priceMatch ? parseInt(priceMatch[priceMatch.length - 1]) : 0
    const name = text.replace(/–¥–æ–±–∞–≤\w*\s+—Ç–æ–≤–∞—Ä\s*/i, '').replace(/\d+/g, '').trim()
    
    return { action: 'add_product', name, price }
  }
  
  // –í–æ–∑–≤—Ä–∞—Ç
  if (lower.includes('–≤–æ–∑–≤—Ä–∞—Ç') || lower.includes('refund')) {
    const numberMatch = text.match(/\d+/)
    return { action: 'refund', orderId: numberMatch ? numberMatch[0] : null }
  }
  
  // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
  if (lower.includes('—Å—Ç–∞—Ç–∏—Å—Ç–∏–∫') || lower.includes('stats')) {
    return { action: 'stats' }
  }
  
  // –ü–æ–º–æ—â—å
  return { action: 'help' }
}

async function createBot() {
  const bot = new Bot(BOT_TOKEN)
  await bot.init()
  // prisma —É–∂–µ –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω –≥–ª–æ–±–∞–ª—å–Ω–æ

  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∞
  function isAdmin(userId: string): boolean {
    return ADMIN_IDS.includes(userId)
  }

  // –ö–æ–º–∞–Ω–¥–∞ —Å—Ç–∞—Ä—Ç
  bot.command('start', async (ctx) => {
    if (!ctx.from || !isAdmin(ctx.from.id.toString())) {
      await ctx.reply('‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–º—É –±–æ—Ç—É')
      return
    }

    await ctx.reply(
      'üëã *–£–º–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç VOBVOROT*\\n\\n' +
      '–ü—Ä–æ—Å—Ç–æ –ø–∏—à–∏—Ç–µ, —á—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å:\\n\\n' +
      'üì¶ "–ü–æ–∫–∞–∂–∏ –∑–∞–∫–∞–∑—ã –∑–∞ —Å–µ–≥–æ–¥–Ω—è"\\n' +
      'üõç "–î–æ–±–∞–≤—å —Ç–æ–≤–∞—Ä –ü–ª–∞—Ç—å–µ –∫—Ä–∞—Å–Ω–æ–µ 2500"\\n' +
      'üí≥ "–û—Ñ–æ—Ä–º–∏ –≤–æ–∑–≤—Ä–∞—Ç –¥–ª—è –∑–∞–∫–∞–∑–∞ 123"\\n' +
      'üìä "–ü–æ–∫–∞–∂–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"\\n\\n' +
      '_–ë–æ—Ç –ø–æ–Ω–∏–º–∞–µ—Ç –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —è–∑—ã–∫!_',
      { parse_mode: 'Markdown' }
    )
  })

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–∞
  bot.on('message:text', async (ctx) => {
    if (!ctx.from || !isAdmin(ctx.from.id.toString())) {
      await ctx.reply('‚õî –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞')
      return
    }

    const command = parseCommand(ctx.message.text)
    
    try {
      switch (command.action) {
        case 'view_orders':
          let whereClause = {}
          const now = new Date()
          
          if (command.filter === 'today') {
            const startOfDay = new Date(now)
            startOfDay.setHours(0, 0, 0, 0)
            whereClause = {
              createdAt: { gte: startOfDay }
            }
          } else if (command.filter === 'yesterday') {
            const yesterday = new Date(now)
            yesterday.setDate(yesterday.getDate() - 1)
            yesterday.setHours(0, 0, 0, 0)
            const endOfYesterday = new Date(yesterday)
            endOfYesterday.setHours(23, 59, 59, 999)
            
            whereClause = {
              createdAt: {
                gte: yesterday,
                lte: endOfYesterday
              }
            }
          }
          
          const orders = await prisma.order.findMany({
            where: whereClause,
            include: {
              orderItems: { include: { product: true } },
              customer: true
            },
            orderBy: { createdAt: 'desc' },
            take: 5
          })
          
          if (orders.length === 0) {
            await ctx.reply('üì¶ –ó–∞–∫–∞–∑–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ')
            return
          }
          
          let message = `üì¶ *–ù–∞–π–¥–µ–Ω–æ –∑–∞–∫–∞–∑–æ–≤: ${orders.length}*\\n\\n`
          
          for (const order of orders) {
            const items = order.orderItems.slice(0, 3).map(item => 
              `  ‚Ä¢ ${item.product.name}`
            ).join('\\n')
            
            message += `üõç *–ó–∞–∫–∞–∑ #${order.orderNumber}*\\n`
            message += `üë§ ${order.customer.name}\\n`
            message += `üí∞ $${order.totalAmount} | üì¶ ${order.status}\\n`
            if (order.orderItems.length > 0) {
              message += `–¢–æ–≤–∞—Ä—ã:\\n${items}\\n`
              if (order.orderItems.length > 3) {
                message += `  _...–∏ –µ—â–µ ${order.orderItems.length - 3}_\\n`
              }
            }
            message += '\\n'
          }
          
          await ctx.reply(message, { parse_mode: 'Markdown' })
          break

        case 'add_product':
          if (!command.name || !command.price) {
            await ctx.reply(
              '‚ùå –ù–µ –º–æ–≥—É —Ä–∞–∑–æ–±—Ä–∞—Ç—å –∫–æ–º–∞–Ω–¥—É\\n\\n' +
              '–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Ç–∞–∫:\\n' +
              '"–î–æ–±–∞–≤—å —Ç–æ–≤–∞—Ä –ü–ª–∞—Ç—å–µ –∫—Ä–∞—Å–Ω–æ–µ 2500"'
            )
            return
          }
          
          const product = await prisma.product.create({
            data: {
              name: command.name,
              description: '',
              price: command.price,
              stock: 1,
              brandName: 'VOBVOROT',
              categoryId: 1,
              status: 'active'
            }
          })
          
          await ctx.reply(
            `‚úÖ *–¢–æ–≤–∞—Ä –¥–æ–±–∞–≤–ª–µ–Ω!*\\n\\n` +
            `üì¶ ${product.name}\\n` +
            `üí∞ –¶–µ–Ω–∞: $${product.price}\\n` +
            `üÜî ID: ${product.id}\\n\\n` +
            `_–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ —Ç–æ–≤–∞—Ä–∞ –æ—Ç–≤–µ—Ç–æ–º –Ω–∞ —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ_`,
            { parse_mode: 'Markdown' }
          )
          break

        case 'refund':
          if (!command.orderId) {
            await ctx.reply('‚ùå –£–∫–∞–∂–∏—Ç–µ –Ω–æ–º–µ—Ä –∑–∞–∫–∞–∑–∞. –ù–∞–ø—Ä–∏–º–µ—Ä: "–í–æ–∑–≤—Ä–∞—Ç –¥–ª—è –∑–∞–∫–∞–∑–∞ 123"')
            return
          }
          
          const order = await prisma.order.findFirst({
            where: { orderNumber: command.orderId },
            include: { customer: true }
          })
          
          if (!order) {
            await ctx.reply(`‚ùå –ó–∞–∫–∞–∑ #${command.orderId} –Ω–µ –Ω–∞–π–¥–µ–Ω`)
            return
          }
          
          await ctx.reply(
            `üí≥ *–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤–æ–∑–≤—Ä–∞—Ç–∞*\\n\\n` +
            `–ó–∞–∫–∞–∑: #${order.orderNumber}\\n` +
            `–ö–ª–∏–µ–Ω—Ç: ${order.customer.name}\\n` +
            `–°—É–º–º–∞: $${order.totalAmount}\\n\\n` +
            `–û—Ñ–æ—Ä–º–∏—Ç—å –ø–æ–ª–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç?`,
            {
              parse_mode: 'Markdown',
              reply_markup: {
                inline_keyboard: [[
                  { text: '‚úÖ –î–∞, –≤–µ—Ä–Ω—É—Ç—å', callback_data: `refund_${order.id}` },
                  { text: '‚ùå –û—Ç–º–µ–Ω–∞', callback_data: 'cancel' }
                ]]
              }
            }
          )
          break

        case 'stats':
          const stats = await prisma.$transaction([
            prisma.order.count(),
            prisma.order.count({ where: { createdAt: { gte: new Date(new Date().setHours(0,0,0,0)) } } }),
            prisma.product.count({ where: { status: 'active' } }),
            prisma.customer.count(),
            prisma.order.aggregate({ _sum: { totalAmount: true } })
          ])
          
          await ctx.reply(
            `üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –º–∞–≥–∞–∑–∏–Ω–∞*\\n\\n` +
            `üì¶ –í—Å–µ–≥–æ –∑–∞–∫–∞–∑–æ–≤: ${stats[0]}\\n` +
            `üìÖ –ó–∞–∫–∞–∑–æ–≤ —Å–µ–≥–æ–¥–Ω—è: ${stats[1]}\\n` +
            `üõç –ê–∫—Ç–∏–≤–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤: ${stats[2]}\\n` +
            `üë• –ö–ª–∏–µ–Ω—Ç–æ–≤: ${stats[3]}\\n` +
            `üí∞ –û–±—â–∞—è —Å—É–º–º–∞: $${stats[4]._sum.totalAmount || 0}`,
            { parse_mode: 'Markdown' }
          )
          break

        default:
          await ctx.reply(
            'üí° *–ü—Ä–∏–º–µ—Ä—ã –∫–æ–º–∞–Ω–¥:*\\n\\n' +
            'üì¶ –ü–æ–∫–∞–∂–∏ –∑–∞–∫–∞–∑—ã\\n' +
            'üì¶ –ó–∞–∫–∞–∑—ã –∑–∞ —Å–µ–≥–æ–¥–Ω—è\\n' +
            'üì¶ –ó–∞–∫–∞–∑—ã –∑–∞ –≤—á–µ—Ä–∞\\n\\n' +
            'üõç –î–æ–±–∞–≤—å —Ç–æ–≤–∞—Ä –ü–ª–∞—Ç—å–µ —Å–∏–Ω–µ–µ 3000\\n' +
            'üõç –î–æ–±–∞–≤—å —Ç–æ–≤–∞—Ä –°—É–º–∫–∞ –∫–æ–∂–∞–Ω–∞—è 5500\\n\\n' +
            'üí≥ –û—Ñ–æ—Ä–º–∏ –≤–æ–∑–≤—Ä–∞—Ç –¥–ª—è –∑–∞–∫–∞–∑–∞ 123\\n\\n' +
            'üìä –ü–æ–∫–∞–∂–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É',
            { parse_mode: 'Markdown' }
          )
      }
    } catch (error) {
      console.error('Error:', error)
      await ctx.reply('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ –∫–æ–º–∞–Ω–¥—ã')
    }
  })

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ callback
  bot.on('callback_query:data', async (ctx) => {
    const data = ctx.callbackQuery.data
    
    if (data.startsWith('refund_')) {
      const orderId = data.replace('refund_', '')
      
      try {
        await prisma.order.update({
          where: { id: orderId },
          data: { 
            status: 'refunded',
            refundedAt: new Date()
          }
        })
        
        await ctx.answerCallbackQuery('‚úÖ –í–æ–∑–≤—Ä–∞—Ç –æ—Ñ–æ—Ä–º–ª–µ–Ω')
        await ctx.editMessageText('‚úÖ –í–æ–∑–≤—Ä–∞—Ç —É—Å–ø–µ—à–Ω–æ –æ—Ñ–æ—Ä–º–ª–µ–Ω!')
      } catch (error) {
        await ctx.answerCallbackQuery('‚ùå –û—à–∏–±–∫–∞')
      }
    }
    
    if (data === 'cancel') {
      await ctx.answerCallbackQuery('‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ')
      await ctx.editMessageText('‚ùå –û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞')
    }
  })

  // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ñ–æ—Ç–æ
  bot.on('message:photo', async (ctx) => {
    await ctx.reply(
      'üì∏ –§–æ—Ç–æ –ø–æ–ª—É—á–µ–Ω–æ!\\n\\n' +
      '_–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–æ—Ç–æ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∞–¥–º–∏–Ω–∫—É —Å–∞–π—Ç–∞ –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è._',
      { parse_mode: 'Markdown' }
    )
  })

  return bot
}

// Webhook handler
const handler = async (req: NextRequest) => {
  try {
    const bot = await createBot()
    const handleUpdate = webhookCallback(bot, 'std/http')
    
    return handleUpdate(req)
  } catch (error) {
    console.error('Webhook error:', error)
    return new Response('Error', { status: 500 })
  }
}

export const POST = handler